// Package trace gives access to direct control over the span and trace objects
// used by the beeline.
//
// Summary
//
// Elementary use of the Honeycomb beeline has few needs - use a wrapper to
// cover most of the basic info about a given event and then augment that event
// with a few fields using `beeline.AddField`. Occasionally add an additional
// span to the trace that is automatically created and add fields to that.
// However, as the beeline starts being used in more sophisticated applications,
// or new wrapers are being written, more direct control is needed to manipulate
// the spans and traces generated by the beeline.  Using the `trace` package
// enables this more sophisticated use.
//
// The types of use that are enabled by using the trace package:
//
// 1) creating asynchronous spans; spans that outlive the main trace. These spans
// are especially useful for goroutines that manage some background task after
// the main user-facing chore has been completed. Examples of this are sending
// an email or persisting accepted data.
//
// 2) creating traces with upstream parents when you are a downstream service.
// The existing HTTP wrappers do this for you, but if your trace is getting
// propagated via kafka or SQS or some other mechanism you may need to do this
// yourself
//
// 3) adding fields that use a different naming scheme. Fields added via the
// beeline are all namespaced under `app.`, which is convenient when you're
// adding a few. When you have more complicated code to manage, it can be
// useful to use your own naming scheme. Adding fields directly to the span or
// trace objects allows you to specify the full field name with no prefix.
//
// Enjoy!
package trace
